'use strict';

var stream_url = require('stream-url');
var lamp64 = require('swarm-stamp');
var Spec =  require('./Spec');
var Op = require('./Op');
var Syncable = require('./Syncable');
var OpStream =  require('./OpStream');
var util         = require("util");
var EventEmitter = require("events").EventEmitter;

// Host is the world of actual Syncable CRDT objects of various types.
// A (full) Swarm node is Host+Storage+Router.
function Host (options) {
    EventEmitter.call(this);
    // id, router, offset_ms
    this.options = options;
    this.ssn_id = null;
    this.db_id = null;
    this.clock = null;
    this.upstream = null;
    // syncables, API objects, outer state
    this.syncables = Object.create(null);
    // CRDTs, inner state
    this.crdts = Object.create(null);
    // pending writes to handle on replica reconnection
    this.pendings = Object.create(null);
    if (options.ssn_id) {
        this.ssn_id = options.ssn_id;
    }
    if (options.clock) {
        this.clock = options.clock;
    } else if (this.ssn_id) {
        this.clock = new lamp64.Clock(this.ssn_id);
    }
    if (options.db_id) {
        this.db_id = options.db_id;
    }
    if (options.upstream) {
        if (typeof options.upstream.write!=='function') {
            var self = this;
            stream_url.connect(options.upstream, function(err, stream) {
                if (err) {
                    console.error('connection failed', err); // FIXME reconnect
                } else {
                    self.setUpstream(stream);
                }
            });
        } else {
            this.setUpstream(options.upstream);
        }
    }
    if (!Host.multihost) {
        if (Host.localhost) {
            throw new Error('not in multihost mode');
        }
        Host.localhost = this;
    }
}
util.inherits(Host, EventEmitter);
module.exports = Host;
Host.debug = false;


Host.prototype.close = function () {
    if (Host.localhost===this) {
        Host.localhost = null;
    }
};

// mark-and-sweep kind-of distributed garbage collection
Host.prototype.gc = function (criteria) {
    // NOTE objects in this.pending can NOT be gc'd
};


Host.prototype.setUpstream = function (stream) {
    var upstream = this.upstream = new OpStream(stream, {
        peer_stamp: 'upstream'
    });
    var hs = this.handshake();
    upstream.sendHandshake(hs);
    upstream.setContext( new Spec.Parsed( '/Model!'+ hs.stamp() + '.on' ));
    upstream.on('data', this.write.bind(this));

    // FIXME ugly
    var typeids = Object.keys(this.syncables), crdts = this.crdts;
    var pendings = this.pendings;
    var stateless = typeids.filter(function(ti){ return !(ti in crdts); });
    stateless.forEach(function(typeid){
        upstream.write(new Op(typeid+'.on', ''));
    });
    var changeds = Object.keys(pendings);
    changeds.forEach(function(typeid){
        upstream.write(new Op(typeid+'.on', pendings[typeid].last, pendings[typeid].patch));
    });
    var statefuls = Object.keys(this.crdts).filter(function(ti){
        return !(ti in pendings);
    });
    statefuls.forEach(function(typeid){
        upstream.write(new Op(typeid+'.on', crdts[typeid]._version));
    });


    // FIXME resync, buffer local changes
};


Host.prototype.handshake = function () {
    if (!this.ssn_id || !this.db_id) { return null; }
    var key = new Spec('/Swarm+Host').add(this.db_id, '#')
        .add(this.time(),'!').add('.on');
    return new Op(key, '');
};

/**
 * Returns an unique Lamport timestamp on every invocation.
 * Swarm employs 30bit integer Unix-like timestamps starting epoch at
 * 1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
 * several events are generated by the same process at the same second
 * then sequence number is added so a timestamp may be more than 5
 * chars. The id of the Router (+user~session) is appended to the ts.
 */
Host.prototype.time = function () {
    return this.clock ? this.clock.issueTimestamp() : null;
};

// An innner state getter; needs /type#id spec for the object.
Host.prototype.getCRDT = function (obj) {
    if (obj._type) {
        if (obj._owner!==this) {
            throw new Error('an alien object');
        }
        return this.crdts[obj.typeid()];
    } else {
        return this.crdts[new Spec.Parsed(obj).typeid()];
    }
};

// Applies a serialized operation (or a batch thereof) to this replica
Host.prototype.write = function (op) {

    var typeid = op.spec.typeid(), self=this;
    var syncable = this.syncables[typeid];
    var crdt = this.crdts[typeid];
    if (!syncable) {
        throw new Error('syncable not open');
    }

    switch (op.op()) {
    case 'on':
        op.patch && op.patch.forEach(function(op){
            self.write(op);
        });


        /*crdt.updateSyncable(syncable);
        syncable.emit('change', {
            version: crdt._version,
            changes: null
        });*/


        break;
    case 'off':
        break;
    case '~state':
        var type_fn = Syncable.types[op.spec.type()];
        if (!type_fn) {
            throw new Error('type unknown');
        }
        crdt = this.crdts[typeid] = new type_fn.Inner(op.value);


        // FIXME pending state!!!


        crdt.updateSyncable(syncable);
        syncable._version = crdt._version = op.stamp();
        syncable.emit('init', {
            version: crdt._version,
            changes: null
        });
        break;
    case 'error':
        // As all the event/operation processing is asynchronous, we
        // cannot simply throw/catch exceptions over the network.
        // This method allows to send errors back asynchronously.
        // Sort of an asynchronous complaint mailbox :)
        console.error('something failed:', ''+op.spec, op.value);
    break;
    default: // actual ops
        crdt = this.crdts[typeid];
        if (!crdt) {
            throw new Error('CRDT object was not initialized');
        }
        crdt.write(op);


        var pending = this.pendings[typeid];
        if (pending) {
            pending.last = op.stamp();
            if (pending.patch[0].stamp()===op.stamp()) {
                pending.patch.shift();
                if (!pending.patch.length) {
                    delete this.pendings[typeid];
                }
            }
        }



        crdt.updateSyncable(syncable);
        syncable._version = crdt._version = op.stamp();
        syncable.emit('change', {
            version: crdt._version,
            changes: null
        });
    }

    // NOTE: merged ops, like
    //      !time+src.in text
    // should have their *last* stamp in the spec
};

// The method must decide whether the source of the operation has
// the rights to perform it. The method may check both the nearest
// source and the original author of the op.
// If this method ever mentions 'this', that is a really bad sign.
// @returns {boolean}
Host.prototype.acl = function (op) {
    return true;
};

// Inner state lifecycle:
// * unknown (outer: default, '')
// * created fresh: constructor, sent
// * arrived : parse, create, rebuild()
// SCHEME
/**
 * Register a syncable object.
 */

// Incorporate a syncable into this replica.
// In case the object is newly created (like `new Model()`), Host
// assigns an id and saves it. For a known-id objects
// (like `new Model('2THjz01+gritzko~cA4')`) the state is queried
// from the storage/uplink. Till the state is received, the object
// is stateless (`syncable.version()===undefined && !syncable.hasState()`)
Host.prototype.adoptSyncable = function (syncable, init_op) {
    var type = syncable._type, on_op;
    var type_fn = Syncable.types[type];
    if (!type_fn || type_fn!==syncable.constructor) {
        throw new Error('not a registered syncable type');
    }
    if (syncable._owner) {
        throw new Error('the syncable belongs to some host already');
    }

    if (!syncable._id) { // it is a new object; let's add it to the system

        var stamp = this.time();
        syncable._id = stamp;
        var typeid = syncable.spec();
        var crdt = new syncable.constructor.Inner(null, syncable); // 0 state
        if (init_op) {
            var stamped_spec = typeid.add(stamp,'!').add(init_op.op(),'.');
            var stamped_op = new Op(stamped_spec, init_op.value);
            crdt.write(stamped_op);
        }
        this.crdts[typeid] = crdt;
        crdt._version = stamp;
        crdt.updateSyncable(syncable);
        syncable._version = crdt._version = stamp;

        // the state is sent up in the handshake as the uplink has nothing
        var state_op = new Op('!'+stamp+'.~state', crdt.toString());
        var on_spec = syncable.spec().add('.on');
        on_op = new Op(on_spec, '0', null, [state_op]);

    } else {
        var spec = syncable.spec().toString();
        if (spec in this.syncables) {
            return this.syncables[spec]; // there is such an object already
        }
        // !0 up
        on_op = new Op(syncable.spec().add('.on'), '');
    }

    this.syncables[syncable.spec().typeid()] = syncable;  // OK, remember it
    syncable._owner = this;
    if (this.upstream) {
        this.upstream.write(on_op);
    } else if (on_op.patch) {

        this.pendings[typeid] = {
            last: '0',
            patch: on_op.patch
        };
    }

    return syncable;
};


Host.prototype.abandonSyncable = function (obj) {
    var typeid = obj.spec().typeid();
    if (typeid in this.syncables) {
        if (this.syncables[typeid]!==obj) {
            throw new Error('the registered object is different');
        }
        delete this.syncables[typeid];
        if (this.upstream) {
            var off_spec = obj.spec().add('.off');
            var off_op = new Op (off_spec, '');
            this.upstream.write(off_op);
        }
    }
};

var just_model = new Spec.Parsed('/Model'); // FIXME

// Retrieve an object by its spec (type and id).
// Optionally, invoke a callback once the state is actually available.
Host.prototype.get = function (spec, callback) {
    if (spec.constructor===Function) {
        spec = new Spec.Parsed('/'+spec._type);
    }
    if (spec.constructor!==Spec.Parsed) {
        spec = new Spec.Parsed(spec.toString(), null, just_model);
    }
    if (!spec.type()) {
        throw new Error('type not specified');
    }
    var type_fn = Syncable.types[spec.type()];
    if (!type_fn) {
        throw new Error('type unknown: ' + spec.type());
    }
    var object;
    if (spec.id()) {
        var typeid = spec.typeid();
        object = this.syncables[typeid];
        if (!object) {
            object = new type_fn(null, null);
            object._id = spec.id();
            this.adoptSyncable(object);
        }
    } else {
        object = new type_fn(null, this);
    }
    if (callback) {
        object.onInit(callback);
    }
    return object;
};

// author a new operation
Host.prototype.submit = function (syncable, op_name, value) { // TODO sig
    if (syncable._owner!==this) {
        throw new Error('alien op submission');
    }
    var typeid = syncable.typeid();
    var crdt = this.crdts[typeid];
    if (!crdt) {
        throw new Error('have no state, can not modify');
    }
    var spec = syncable.spec().add(this.time(), '!').add(op_name,'.');
    var op = new Op(spec, value, this.id);

    var pending = this.pendings[typeid];
    if (!pending) {
        pending = this.pendings[typeid] = {
            last: crdt._version,
            patch: [op]
        };
    } else {
        pending.patch.push(op);
    }

    this.write(op);
    if (this.upstream) {
        this.upstream.write(op);
    }
};


/*
//   new -> link -> ...
Host.prototype.create = function (spec) {
    var type = new Spec(spec, '/').type();
    var type_constructor = Syncable.types[type];
    if (!type_constructor) {
        throw new Error('type unknown: ' + spec);
    }
    var stamp = this.time();
    var state = new Spec(type, '/').add(stamp, '#').add('!0.state');
    var op = new Op(state, '', this.id);
    var inner = new type_constructor.Inner(op);
    this.crdts[op.spec.filter('/#')] = inner;
    this.upstream.write(op, this);
    return new type_constructor(stamp, this);
};
*/
