'use strict';

var env = require('./env');
var Spec = require('./Spec');
var Op = require('./Op');
var Syncable = require('./Syncable');
var Storage = require('./Storage');
var Pipe = require('./Pipe');
var Logics = require('./Logics');
var SecondPreciseClock = require('./SecondPreciseClock');

/** Swarm has three orthogonal parts: Logics, Host and Storage.
 * Storage is a key-value db for operation logs (op logs).
 * Logics is a world of syncable CRDT syncables that consume ops.
 * Host deals with object subscriptions and op forwarding.
 *
 * Practically, a Host is a client (browser/mobile) or a server process.
 * Differently from other classes of systems, Swarm deals with
 * per-object subscriptions so a developer may use an arbitrary
 * collection of "live" replicated syncables (syncables) on the
 * client side. The resulting (asynchronous!) message exchange
 * patterns are quite complicated: per-object subscriptions,
 * operation forwarding, secondary clients, relinking to maintain
 * a consistent hashing ring etc.
 * Host focuses exactly on that part of the problem, so the Storage
 * may stay key-value dumb and Logics may be mathematically pure.
 * Host maintains local clocks and, generally, glues it all together.
 */
function Host(id, ms, storage) {
    this.id = id;
    this.storage = storage || new Storage();
    // "special" pipes: logics is "0+host_id", storage is "1+host_id"
    this.storage.id = '1+' + this.id;
    this._server = /^swarm~.*/.test(id);

    this.clock = env.clock || new SecondPreciseClock(this.id, ms||0);

    this.logics = new Logics(this);

    this.subscriptions = {};

    // peer_pipe_id keyed pipes
    this.pipes = {};
    // local pipe id to peer pipe id mapping (the peer's id for the pipe)
    this.pid2ppid = {};
    // peer id to peer pipe id mapping (the current pipe)
    this.src2ppid = {};

    this.servers = {};

    if (this.storage) {
        this.storage.host = this;
    }

    if (!env.multihost) {
        if (env.localhost) {
            throw new Error('use multihost mode');
        }
        env.localhost = this;
    }

    // setInterval(this.maintenance.bind(this));
}

module.exports = Host;


/**
 * Returns an unique Lamport timestamp on every invocation.
 * Swarm employs 30bit integer Unix-like timestamps starting epoch at
 * 1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
 * several events are generated by the same process at the same second
 * then sequence number is added so a timestamp may be more than 5
 * chars. The id of the Host (+user~session) is appended to the ts.
 */
 Host.prototype.time = function () {
    var ts = this.clock.issueTimestamp();
    this._version = ts;
    return ts;
};

Host.prototype.newEventSpec = function (evname) {
    var spec = this.spec().add(this.time(),'!');
    return spec.add(evname,'.');
};

Host.prototype.spec = function () {
    return new Spec('/Host').add(this.id,'#');
};

/********************* op dispatching *********************



 **********************************************************/



/** The primary op routing function */
Host.prototype.deliver = function (op, pipe) {// TODO "synchronized"

    if (op.constructor!==Op) {
        throw new Error('ops only');
    }

    var ti = op.spec.filter('/#');
    var id = op.spec.id();

    env.logs.host && console.log((op.source||'unknown')+'>'+this.id, op.toString());

    if (op.spec.type() === 'Host') { // handshake from a (remote) Host
        return this.dispatchHostHandshake(op, pipe);
    } else {
        if (id===op.spec.version()) { // state push
            this.store(op);
            return;
        } else if (!op.source) {
            throw new Error('handshake first');
        }
    }

    var sub = this.subscriptions[ti];
    if (!sub) {
        sub = this.subscriptions[ti] = new Subscription(id, Modes.SEEK_STATE);
        var uplink = this.getUplink(id) || '0';
        this.linkTo(op.spec.filter('/#'), sub, uplink); // even if none
    }

    if (pipe===this.storage) { // own storage
        switch (sub.state()) {
        case Modes.GC: this.dispatchGcStore(op, sub, pipe); break;
        case Modes.SEEK_STATE: this.dispatchSeekStore(op, sub, pipe); break;
        case Modes.CACHE: this.dispatchCacheStore(op, sub, pipe); break;
        case Modes.FORWARD: this.dispatchFwdStore(op, sub, pipe); break;
        }
    } else if (pipe && pipe.peer_pipe_id===sub.uplink) {
        switch (sub.state()) {
        case Modes.GC: this.dispatchGcUl(op, sub, pipe); break;
        case Modes.SEEK_STATE: this.dispatchSeekUl(op, sub, pipe); break;
        case Modes.CACHE: this.dispatchCacheUl(op, sub, pipe); break;
        case Modes.FORWARD: this.dispatchFwdUl(op, sub, pipe); break;
        }
    } else { // for most practical purposes, Logics is "downstream"
        this.acl(op, sub, pipe);
        switch (sub.state()) {
        case Modes.GC: this.dispatchGcDl(op, sub, pipe); break;
        case Modes.SEEK_STATE: this.dispatchSeekDl(op, sub, pipe); break;
        case Modes.CACHE: this.dispatchCacheDl(op, sub, pipe); break;
        case Modes.FORWARD: this.dispatchFwdDl(op, sub, pipe); break;
        }
    }

};

Host.prototype.maintenance = function () {
    // gc
    //if (sub.mode&Modes.GC) {
    //}
    // stale states
};

Host.prototype.acl = function (op, sub, pipe) {
    if (op.op() in Op.handshake_ops) {
        if (pipe &&
            op.stamp()!==pipe.pipe_id &&
            op.stamp()!==pipe.peer_pipe_id)
        {
            throw new Error('misleading source id');
        }
    }
};

var Modes = {
    GC: 0,
    SEEK_STATE: 1,
    CACHE: 2,
    FORWARD: 3,
    STATES: 3,
    DESPERATE: 8,
    PULL_STATE: 16,
    SHARED: 32
};

/** Subscription state object. */
function Subscription (id, mode) {
    // per-object subscription mode flags (see Modes above)
    this.changeMode(~0, mode);
    // the uplink node (also mirror)
    this.uplink = null;
    // it is not yet clear whether we have the state locally
    this.pending = []; // ops
    // queried and patched; joined the spanning tree
    this.links = []; // ppids
}
// Once a handshake is completed (.diff, .reon) a peer host starts
// listening to object's new ops (we add it to this.links[id]).
// On .off received or connection breakage we remove the entry.
// Once we start tracking an object we join its spanning tree.
// Triggered by an incoming .on or local new Syncable(), link()
// calculates the uplink for the object, sends out .on and puts
// pipe id in this.unlinks.
// Later on handshake completion, the same pipe id gets listed
// in this.links.
// The entry is overwritten on uplink departure/arrival, removed
// by uplink() (triggered by an incoming .off or local gc()).
// --Incoming .on/.reon operations are forwarded (to Storage, uplink,
// downlink) to receive a response (a .diff, maybe an empty one).
// Such pending ops are remembered to forward the response back.
// A diff clears pending state, creates linked state (this.links)

Subscription.prototype.changeMode = function (clear, set) {
    var new_mode = (this.mode & ~clear) | set;
    console.log(this.mode,'->',new_mode);
    this.mode = new_mode;
};

Subscription.prototype.state = function () {
    return this.mode & Modes.STATES;
};


Host.prototype.dispatchSeekUl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on': // OK, the ul has no state then
        sub.pending.push(op);
        this.askSomeone(op, sub);
    break;
    case 'diff':
        this.store(op);
        this.goCache(op, sub);
    break;
    case 'off':
        // ? the uplink defects
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        this.send(op.reply('error','op sent to stateless replica'));
    break;
    }
};

Host.prototype.dispatchSeekDl = function (op, sub, pipe) {
    var mode = sub.mode;
    switch (op.op()) {
    case 'on':
        if ( (op.value && (mode&Modes.PULL_STATE)) || (mode&Modes.DESPERATE) ){
            // pull the state from a dl
            this.send(op.reply('on', ''));
            /*var pipe = this.pipes[op.stamp()];
            if (!pipe) {
                console.warn('unknown pipe');
                return;
            }*/
            // queue a reon so the storage responds with a diff only
            var ti = op.spec.filter('/#');
            var reon = ti.add(pipe.pipe_id,'!').add('.on');
            sub.pending.push(new Op(reon, op.value, op.stamp()));
        } else {
            sub.pending.push(op);
        }
    break;
    case 'diff':
        // security checks (has uplink responded?)
        if (mode&Modes.PULL_STATE) {
            this.store(op);

            /*pipe = this.pipes[op.stamp()]; // FIXME UGLY
            if (pipe) {
                stamp = pipe.pipe_id;
                for(var i=0; i<sub.pending.length; i++) {
                    var o = sub.pending[i];
                    if (o.stamp()===stamp) {
                        o.value = op.spec.filter('!').toString();
                    }
                }  FIXME need to unbundle diff to see state ver
            }*/

        } else {
            console.warn('preemptive diff from a dl', ''+op);
        }
        this.goCache(op, sub);
    break;
    case 'off':
        var pending = sub.pending, stamp = op.stamp();
        for(var i=0; i<pending.length && pending[i].stamp()!==stamp;){i++;}
        if (i<pending.length) {
            pending.splice(i,1);
        } else {
            console.warn('.off for a non-existing .on', ''+op);
        }
    break;
    case 'state':
        if (sub.pending.length) {
            console.warn('reordered state push?');
        } else {
            this.store(op);
        }
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        // this.send(op.reply('error','op sent to a stateless replica'));
        this.store(op);
    break;
    }
};

Host.prototype.dispatchSeekStore = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
        // the only .on the storage received at this stage is
        // a simulated uplink .on
        if (op.stamp()===sub.uplink) {
            this.forwardPreon(op, sub);
        } else {
            throw new Error('highly unexpected .on');
        }

        if (op.value) {
            this.goCache(op, sub);
        } else if (sub.uplink==='0') {
            this.askSomeone(op, sub);
        }
    break;
    case 'diff': // OK, the storage has the state
        this.goCache();
    break;
    case 'off':
        this.store(op.reply('error'), 'what?!');
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        this.store(op.reply('error'), 'diff first');
    break;
    }
};

Host.prototype.dispatchCacheUl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
        this.store(op);
    break;
    case 'diff':
        this.store(op);
    break;
    case 'off':
        // ?
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        this.store(op);
    break;
    }
};

Host.prototype.dispatchCacheDl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
        this.store(op);
        // ??? if (op.origin()!==this.id) {
        //    this.send(op.reply('on',''));
        //}
    break;
    case 'diff':
        this.store(op);
    break;
    case 'off':
        var i = sub.links.indexOf(op.stamp());
        i!==-1 && sub.links.splice(i,1);
        this.send(op.reply('off'));
    break;
    case 'state':
        this.send(op.reply('error'), 'state push for a stateful object');
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        this.store(op);
    break;
    }
};

Host.prototype.id2ppid = function (id) {
    if (id in this.pipes) { return id; }
    if (id in this.pid2ppid) { return this.pid2ppid[id]; }
    if (id in this.src2ppid) { return this.src2ppid[id]; }
    return null;
};

Host.prototype.dispatchCacheStore = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
        if (op.stamp()===sub.uplink) {
            // on relink we redo preon > uplink on
            this.forwardPreon(op, sub);
        } else {
            this.send(op.relay(op.stamp())); // TODO chain stamps
        }
    break;
    case 'diff':
        // Once the peer replica state is made equal to our state,
        // all the new ops must be relayed to keep it up to date.
        // In other words, that replica joins our subtree.
        var ppid = this.id2ppid(op.stamp());
        if (!ppid && op.stamp()!=='0+'+this.id) { // FIXME
            console.warn('subscription of unclear origin');
            return;
        }
        this.send(op.relay(ppid || '0+'+this.id)); // TODO chain stamps
        if (!sub.links) { sub.links = []; }
        var stamp = op.stamp();
        if (sub.links.indexOf(stamp)===-1) {
            sub.links.push(stamp);
        } else {
            console.warn('repeated subscription', ''+op.id());
        }
    break;
    case 'off':
        this.store(op.reply('error','what?'));
    break;
    case 'error':
        if (op.source in this.pipes) {
            this.send(op.relay(op.source));
        } else { // TODO
            this.complain(op);
        }
    break;
    default:
        // the storage says it is a new op => relay it
        this.fanout(op, sub);
    break;
    }
};

Host.prototype.dispatchFwdUl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
    case 'diff':
    case 'error':
        this.send(op.strip(sub.uplink));
    break;
    case 'off':
        this.fanout(op.reply('off'), sub);
    break;
    default:
        this.fanout(op, sub);
    break;
    }
};

Host.prototype.dispatchFwdDl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'on':
    case 'diff':
    case 'error':
        // push
        this.send(op.relayMarked(sub.uplink, op.source));
    break;
    case 'off':
        // to accomodate the case of several fwd nodes (fwd chain)
        // a fwd node relays .off if the last downlink is out
        var i = sub.links.indexOf(op.source);
        i!==-1 && sub.links.splice(i, 1);
        if (sub.links.length===0) {
            this.goGc(op);
        }
    break;
    default:
        this.send(op.relay(sub.uplink));
    break;
    }
};

Host.prototype.dispatchFwdStore = function (op, sub, pipe) {
    // this still may happen in case the hash ring changes
    this.store(op.reply('error', 'the object is in fwd mode'));
};


Host.prototype.dispatchGcUl = function (op, sub, pipe) {
    switch (op.op()) {
    case 'off':
        // by popular demand, stop sending stuff
        // and prepare to be deleted
        sub.uplink = null;
    break;
    case 'error':
        this.complain(op);
    break;
    default:
        // some leftover ops, just ignore them;
        // downlinks are not listening anymore
        // (may save them for later, but why?)
    break;
    }
};

// Downlinks may unsubscribe, but they keep sending stuff till
// our .off reaches them. Ignore these ops.
Host.prototype.dispatchGcDl = function (op, sub, pipe) {
    if (op.op()==='error') {
        this.complain(op);
    } else {
        this.send(op.reply('error', 'have some rest'));
    }
};

Host.prototype.dispatchGcStore = function (op, sub, pipe) {
    if (op.op()==='error') {
        this.complain(op);
    } else {
        this.send(op.reply('error', 'have some rest'));
    }
};


// we can't delete the subscription immediately as peers
// are likely to send us some ops till they process our .off
Host.prototype.goGc = function (op, sub, pipe) {
    sub.changeMode(Modes.STATES, Modes.GC);
    var off = op.spec.filter('/#').add(sub.uplink).add('.off');
    this.send(new Op(off, '', sub.uplink));
};


Host.prototype.complain = function (op, msg) {
    console.error(msg||'error reported:', op.toString());
};

Host.prototype.fanout = function (op, sub) {
    // This may echo a new op back to its source.
    // In some cases (server2client) we may need that as
    // an acknowledgement. In other cases (host2logix,
    // client2server) we'd better supress it. FIXME
    for(var i=0; sub.links && i<sub.links.length; i++) {
        var link = sub.links[i];
        if (link===op.source) { // we may skip echo sometimes
            // don't echo to the logix
            if (link==='0+'+this.id) { continue; }
            // TODO don't echo it up
            if (link===sub.uplink) { continue; }
        }
        this.send(op.relay(link));
    }
};


Host.prototype.goCache = function (op, sub, pipe) {
    sub.changeMode(
            Modes.PULL_STATE|Modes.DESPERATE|Modes.STATES,
            Modes.CACHE);
    var self = this;
    if (sub.pending===null) {return;}
    /*var clear = this.pending.filter(function(o){
        return o.stamp() !== stamp;
    });*/
    sub.pending.forEach(function(o){
        self.store(o);
    });
    sub.pending = null;
};

// # Data structure access
// 1 Host.deliver is NOT reentrant
// v this.send() this.store() ?this.consume()
// v Host.proto.dispatchXY(req)
// v sub:{mode,uplink,links,pending} // uplink => on sent
// 5 reon check is op.origin()===this.id
// 6 sub: state-related convenience methods
// # Handshake tricks
// 1 dry handshake: no state? .on back, leave a reon pending
//   (both sides have a reon queued)
// 2 preon -> !peer.on ~ (makes no diff, just a reon)

// query statefuls
Host.prototype.askSomeone = function (op, sub) {
    var pending = sub.pending;
    var self = this;
    function reon (on) {
        var pipe = self.pipes[on.stamp()];
        if (!pipe) {
            console.warn('?');
        }
        var pid = pipe.pipe_id;
        var spec = on.spec.filter('/#').add(pid,'!').add('.on');
        return new Op(spec, on.value, on.source);
    }
    for(var p=0; p<pending.length &&  // FIXME treat logix uniformly
        (!pending[p].value || pending[p].source===('0+'+this.id) ||
        pending[p].origin()===this.id); ) {p++;}
    if ( p<pending.length ) {
        // ask the downlink that has the state
        sub.changeMode(Modes.DESPERATE, Modes.PULL_STATE);
        var o = pending[p];
        this.send(o.reply('on', ''));
        pending[p] = reon(o);
    } else { // we give up, ask all downlink(s) for the state
        //this.pending = [];
        sub.changeMode(0, Modes.DESPERATE|Modes.PULL_STATE);
        for(p=0; p<pending.length && !pending[p].value; p++) {
            o = pending[p];
            if (o.source!==('0+'+this.id) && o.origin()!==this.id) {
                this.send(o.reply('on',''));
                pending[p] = reon(o);
            }
        }
    }
    // These state-seeking reons will not discharge incoming
    // pending subscriptions (this.pending). Once we'll get
    // the state we'll send back "real" reons.
    // Multiple reons per pipe are perfectly aceptable; that
    // may lead to multiple .diffs, but only 1 subscription.
    // FIXME  TIMER for desperates!!!
};




// Q if client contacts fwd, what is the bm ?!!
// A 'swarm'

// FIXME clean-up on disconnection + SOME CONNs ARE CLOSED


//     var preonspec = op.spec.set(this.time(),'!').set('.on');


/** Incoming subscription, essentially a read request for an object.
  * Read for them is write for us (READ=WRITE^-1).
  * Normally, an `.on` is received from  a downlink (client), sometimes
  * from a shortcut (peer) connection. `.on` is reciprocated with
  * `.reon` in case the source has write rights (i.e. may author ops). */


/**  {.reon: !version} {.reon: ''} {.reon: !0} {.reon: !~~~~~} */


/** diffs are groups of operations related to the same object. Those are
 * sent to achieve pseudo-atomicity (when sending a log tail) or as a
 * performance optimization.
 */

/** A state bootstraps a local object replica. State+log is classics.
  * http://en.wikipedia.org/wiki/State_machine_replication
/


/** new Type()  in multihost env it may be safer to use Host.get() or,
  * at least, new Type(id, host) / new Type(somevalue, host) */
Host.prototype.get = function (spec, callback) {
    return this.logics.get(spec, callback);
};


Host.prototype.send = function send (op) {
    if (op.source==='0+'+this.id) { // local logix
        this.logics.deliver(op);
    } else {
        var peer_id = this.src2ppid[op.source] ||
            this.pid2ppid[op.source] || op.source;
        var pipe = this.pipes[peer_id];
        if (pipe) {
            pipe.deliver(op);
        } else {
            console.warn('op sent to nowhere', ''+op, op.source);
        }
    }
};

Host.prototype.store = function (op) {
    this.storage.deliver(op);
};

// TODO .4 no own storage => .off everyone to re-handshake

Host.prototype.gc = function (spec) {
    /*if (links.length===0 && !(id in this.syncables)) { // gc() ?
        delete this.links[id];
        var uplink = this.uplink[id];
        this.send(uplink,spec.set('.off'));
        delete this.uplink[id];
    }*/
};


/********************* peer connections *********************/



Host.prototype.dispatchHostHandshake = function (op, pipe) {
    // We identify subscriptions (links) by their pipe ids
    // to avoid ABA effects (subsribed to a pipe which got reopened).
    // Pipes guarantee operation arrival order, so we can't
    // be any smarter than to open every subscription on a
    // new pipe (can't reuse old subs on a new pipe).
    // Outgoing handshakes use pipe_id (local timestamp).
    // Incoming handshakes use peer_pipe_id (remote timestamp).
    // So, sub.uplink is a local timestamp, which is bad for
    // debugging. Check this.pipes[sub.uplink].id then.
    // sub.links are remote timestamps, much easier to read.
    // P.S. local subscriptions have pipe id '0'
    switch (op.op()) {
    case 'on':    this.hostOn(op, pipe);   break;
    case 'off':   this.hostOff(op, pipe);   break;
    case 'error': this.hostError(op, pipe); break;
    default:      throw new Error('no such thing allowed');
    }
};


/** Handshake operations:
/Host#dbname~cluster!pipeid+user~session.on
/Host#dbname~cluster!pipeid+user~session!peerpipeid+peer~ssn.on TIME

/Host#dbname~cluster!pipeid+user~session.off
/Host#dbname~cluster!pipeid+user~session!peerpipeid+peer~ssn.off
*/
Host.prototype.hostOn = function (op, pipe) {
    var db_cluster = op.id();
    var is_reon = !!pipe.pipe_id;
    pipe.peer_pipe_id = op.stamp();
    pipe.id = op.origin();
    // send a response
    if (!is_reon) {
        var reon = this.newEventSpec('on');
        pipe.pipe_id = reon.version();
        pipe.deliver(new Op(reon, this.clock.ms()));
    } else if (op.value) { // adjust local clocks
        this.clock.adjustTime(op.value);
    }
    // relink subscriptions, etc
    this.addPipe(op.spec, pipe);
};


Host.prototype.hostOff = function (op, pipe) {
    if (op.origin()!==this.id) {
        pipe.deliver(op.reply('off'), '', this.id);
    }
    this.removePipe(op.spec, pipe);
};


Host.prototype.hostError = function (op, pipe) {
    console.error('handshake fails', op.toString());
};

/** A workaround for abnormal close cases (conn broken, etc) */
Host.prototype.onPipeClosed = function (pipe) {
    if (this.pipes[pipe.peer_pipe_id]===pipe) {
        // make up a synthetic .off event
        this.removePipe(this.newEventSpec('off'), pipe);
    }
};



Host.prototype.addPipe = function hostAddPipe(spec, pipe) {
    // by this time, pipe_id, peer_pipe_id are known
    // FIXME check all kinds of consistency
    if (pipe.auth && spec.id()!==pipe.auth) { // TODO id or stamp?
        throw new Error('not authenticated');
    }
    var source = spec.source();
    var ppid = pipe.peer_pipe_id;

    // replacement is different from removal, mostly because
    // we don't want to change all subscriptions twice
    var old_ppid = this.src2ppid[source];
    if (old_ppid) {
        var old = this.pipes[old_ppid];
        old.deliver( new Op(this.spec().add(old.pipe_id,'!').add('.off')) );
        delete this.src2ppid[source];
        delete this.pid2ppid[old.pipe_id];
        delete this.pipes[old_ppid];
        old.close();
    }
    this.pipes[ppid] = pipe;
    this.src2ppid[source] = ppid;
    this.pid2ppid[pipe.pipe_id] = ppid;

    // TODO all these indexes (add/clear)

    // necessarily, a full scan to detect which ones to subscribe
    this.relink(undefined); // TODO old_ppid

    this.emit({
        name: 'connect',
        spec: spec,
        id: pipe.id,
        pipe: ppid
    });
};


Host.prototype.removePipe = function (spec, pipe) {
    var ppid = pipe.peer_pipe_id;
    var pid = pipe.pipe_id;
    var source = pipe.id;
    if (!this.pipes[ppid]) {
        return; // removed already?
    }

    if (this.src2ppid[source] !== ppid) {
        throw new Error('undead pipe: '+ppid);
    }
    delete this.pipes[ppid];
    delete this.src2ppid[source];
    delete this.pid2ppid[pipe.pipe_id];
    pipe.close();

    this.relink(pipe.peer_pipe_id);
    this.cleanUpLinks(pid); // TODO 1Hz

    this.emit({
        name: 'disconnect',
        spec: spec,
        id: source,
        pipe: pid,
        peer: ppid
    });

};


/********************** Spanning tree **********************

    getUplink: peer_pipe_id
    sub.uplink: peer_pipe_id
    preon stamp: peer_pipe_id
    on stamp: pipe_id
    fictive preon (root): 0
    logix on: 0+myself
    send(): peer_pipe_id

 ***********************************************************/


/**
 *
 * Uplink connections may be closed or reestablished so we need
 * to adjust every object's subscriptions time to time.
 */
Host.prototype.linkTo = function (ti, sub, peer_pipe_id) {
    //var ti = op.spec.filter('/#');

    if (sub.uplink===peer_pipe_id) {
        return; // it's OK
    }

    if (sub.uplink) {
        var pipe = this.pipes[sub.uplink];
        if (pipe) {
            var off = ti.add(pipe.pipe_id,'!').add('.off');
            this.send(new Op(off, '', pipe.peer_pipe_id));
        }
        sub.uplink = null;
    }

    if ( peer_pipe_id ) {
        sub.uplink = peer_pipe_id; // prevent repetitions
        this.storePreOn(ti, sub, peer_pipe_id);
    }
};


Host.prototype.forwardPreon = function (op, sub) {
    // time1+uplink -> time2+myself
    if (sub.uplink!==op.stamp()) {
        console.warn('wrong preon uplink');
        return;
    }
    if (sub.uplink==='0') { return; } // fictive
    var pipe = this.pipes[sub.uplink];
    var spec = op.spec.filter('/#').add(pipe.pipe_id, '!').add('.on');
    this.send(new Op(spec, op.value, sub.uplink));
};


Host.prototype.relink = function (peer_pipe_id) {

    for (var ti in this.subscriptions) {
        var sub = this.subscriptions[ti];
        if (peer_pipe_id && sub.uplink!==peer_pipe_id) {continue;}
        sub.uplink = null;
        var uplink = this.getUplink(new Spec(ti).id());
// FIXME all wrong here
        uplink && this.linkTo(new Spec(ti), sub, uplink);
    }

};

Host.prototype.cleanUpLinks = function (removed) {
    var self = this;
return; // FIXME
    for (var ti in this.subscriptions) {
        var sub = this.subscriptions[ti];
        if (sub.links) { // TODO redo inefficient
            var clean = sub.links.filter(function(p){
                return (p==='0') || (p in self.anyid2peerid);
            });
            if (clean.length!==sub.links.length) {
                sub.links = clean;
            }
        }
    }
};

Host.prototype.share = function (ti, peer_id) {
    ti = new Spec(ti).filter('/#');
    // FIXME: cold mode (no sub)
    var sub = this.subscriptions[ti];
    sub.changeMode(0, Modes.SHARED);

    var ppid = this.src2ppid[peer_id];
    var pipe = this.pipes[ppid];
    if (!pipe) {
        console.warn('pipe unknown', ppid);
        return;
    }

    this.storePreOn(ti, sub, ppid);
};

Host.prototype.storePreOn = function (ti, sub, peer_pipe_id) {
    var preon = ti.add(peer_pipe_id,'!').add('.on');
    this.store( new Op(preon, '~', '0') );
    // ask the storage to subscribe to the uplink (if any);
    // the storage may have log bookmarks for that uplink
};

Host.MAX_INT = 9007199254740992;
Host.MAX_SYNC_TIME = 60 * 60000; // 1 hour (milliseconds)
Host.HASH_POINTS = 3;

Host.hashDistance = function hashDistance(pipe, obj) {
    if ((obj).constructor !== Number) {
        if (obj._id) {
            obj = obj._id;
        }
        obj = env.hashfn(obj);
    }
    if (pipe.id) {
        pipe = pipe.id;
    }
    var dist = 4294967295;
    for (var i = 0; i < Host.HASH_POINTS; i++) {
        var hash = env.hashfn(pipe.id + ':' + i);
        dist = Math.min(dist, hash ^ obj);
    }
    return dist;
};

 /* This default
 * implementation uses a simple consistent hashing scheme.
 * Note that a client may be connected to many servers
 * (pipes), so the uplink selection logic is shared.
 * Neither the server nor the storage depend on the particular CRDT
 * type logic so syncables are sorted by #id, irrespectively of their /type.
 */
Host.prototype.getUplink = function (id) {
    var mindist = 4294967295,
        reServer = /^swarm~/, // pipes, not clients
        target = env.hashfn(id),
        closestpipe = null;

    if (reServer.test(this.id)) { // just in case we're the root
        mindist = Host.hashDistance(this.id, target);
        closestpipe = null;
    }

    for (var peer_id in this.pipes) {
        var pipe = this.pipes[peer_id];
        var src_id = pipe.id;
        if ( !reServer.test(src_id) ) {
            continue;
        }
        var dist = Host.hashDistance(src_id, target);
        if (dist < mindist) {
            closestpipe = peer_id;
            mindist = dist;
        }
    }
    return closestpipe;
};


/********************* network-related *********************/




Host.prototype.isUplinked = function () {
    for (var id in this.sources) {
        if (/^swarm~.*/.test(id)) {
            return true;
        }
    }
    return false;
};

Host.prototype.isServer = function () {
    return this._server;
};

function getUriProtocol (uri) {
    var m = uri.match(/^(\w+):.*/);
    if (!m) { throw new Error('invalid URI ' + uri); }
    return m[1].toLowerCase();
}

// waits for handshake from stream
// authorizer, serializer
Host.prototype.listen = function (url, options) {
    var self = this;
    options = options || {};
    var proto = getUriProtocol(url);
    var server_fn = env.servers[proto];
    if (!server_fn) {
        throw new Error('protocol unknown: '+proto);
    }
    var server = server_fn(url, options, on_connection);
    this.servers[url] = server;
    function on_connection (stream) {
        var opts = {uri:url};
        for(var key in options) {
            opts[key]=options[key];
        }
        function pipeize (author) {
            opts.restrictAuthor = author;
            new Pipe (self, stream, opts);
        }
        if ('authorize' in options) {
            options.authorize (stream, pipeize);
        } else {
            pipeize(undefined);
        }
    }
};

// initiate handshake with a pipe
// authorizer, serializer
Host.prototype.connect = function (uri, options) {
    var self = this;
    var proto = getUriProtocol(uri);
    var client_fn = env.clients[proto];
    if (!client_fn) {
        throw new Error('protocol unknown: '+proto);
    }
    options = options || {};
    options.uri = uri;
    var client = client_fn (uri, options, on_connected);
    function on_connected (stream) {
        var pipe = new Pipe(self, client, options);
        var on = self.newEventSpec('on');
        pipe.pipe_id = on.version();
        pipe.deliver(new Op(on, '', self.id));
    }
};

Host.prototype.disconnect = function (id, comment) {
    for(var i in this.pipes) {
        var src = this.pipes[i];
        if (!id || src.uri===id || src.id===id) {
            src.deliver(new Op(this.newEventSpec('off'), comment||'', this.id));
            src.close();
        }
    }
};

Host.prototype.close = function (cb) {
    for(var id in this.sources) {
        this.disconnect(id);
    }
    if (this.storage) {
        this.storage.close(cb);
    } else if (cb) {
        cb();
    }
};

// for local event subscriptions ('connect' etc)
Host.prototype.on = Syncable.prototype.on;
Host.prototype.once = Syncable.prototype.once;
Host.prototype.off = Syncable.prototype.off;
Host.prototype.emit = Syncable.prototype.emit;
