#!/usr/bin/env node
"use strict";
const fs = require('fs');
const path = require('path');
const leveldown = require('leveldown');
const cli = require("commander");
const swarm = require('swarm-protocol');
const sync = require('swarm-syncable');
const peer = require('swarm-peer');
const Stamp = swarm.Stamp;
require('./NodeServerOpStream');

cli
    .version("0.0.1")
    .usage("[options] <db_dir>")
    .option("-l, --listen <url>", "Listen for incoming connections at th URL")
    //.option("-c, --connect <url>", "Connect to a peer at the URL")
    .option("-e --exec [script.js]", "execute a script (default: REPL)")
    .option("-d, --daemon", "daemonize")
    .option("-i --ingest [file.ops]", "ingest ops from a file")
    .option("-g --grep <spec_fitler>", "grep ongoing log events")
    .option("-D, --debug", "debug")
    .parse(process.argv);


if (!cli.args[0]) {
    console.error('no db specified');
    return 1;
}
const db_path = path.resolve(cli.args[0]);
if (!fs.existsSync(db_path) || !fs.statSync(db_path).isDirectory())
    return on_err('the dir does not exist');
const basename = path.basename(db_path);
if (!Stamp.is(basename))
    return on_err('not a proper database replica id (dbid-replid): '+basename);
const dbrid = new Stamp(basename);

const options = {
    debug: !!cli.debug
};
sync.Syncable.OPTIONS.debug = !!cli.debug;
const level = new leveldown(db_path);
const log_os = new peer.PeerOpStream(level, options);
const switch_os = new peer.SwitchOpStream(dbrid, log_os, options, once_ready);


function once_ready (err) {
    if (err) return on_err(err);

    if (cli.exec)
        execute(cli.exec);

    if (cli.grep)
        grep(cli.grep);

    if (cli.ingest)
        ingest(cli.ingest);

    if (cli.daemon)
        require('daemon')();

    if (cli.listen) {
        sync.OpStream.listen(cli.listen, options, switch_os);
    }

}

function execute (exec) {
    if (exec===true) {
        const repl = require('repl');
        repl.start({
            prompt: process.stdout.isTTY ? '\u2276 ' : '',
            useGlobal: true,
            replMode: repl.REPL_MODE_STRICT
        });
    } else if (exec.constructor===String) {
        require(path.resolve('.', exec));
    } else if (exec.constructor===Array) {
        exec.forEach(script => require(path.resolve('.', script)));
    }
}

function grep (filter) {
    if (filter===true) {
        log_os.on(op=>console.log(op.toString()));
    } else if (filter.constructor===String) {
        log_os.on(filter, op=>console.log(op.toString()));
    }
}

function ingest (path) {
    const file = fs.readFileSync(path);
    const ops = swarm.Op.parseFrame(file);
    ops.forEach(op => log_os.offer(op));
}

function on_err (err) {
    console.error('ERROR', err);
    process.exitCode = 1;
}

process.on('uncaughtException', function (err) {
  console.error("UNCAUGHT EXCEPTION", err, err.stack);
});

// process.on('SIGTERM', on_err.bind('SIGTERM')); TODO graceful close
// process.on('SIGINT', on_err.bind('SIGINT'));
// process.on('SIGQUIT', on_err.bind('SIGQUIT'));
