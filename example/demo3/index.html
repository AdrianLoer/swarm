<html>
    <head>
        <title></title>
        <link rel="stylesheet" href="demo3.css">
    </head>
    <body>

        <table>

            <tr>

                <td colspan='3' class='preamble'>
                    <p class='head'>
                        <img src='swarm.png' id='title'></img>
                    </p>
                    <p class='subtitle'>reactive data sync lib:
                        replicated model for your web app</p>

                    <p class='summary'>
                        <!--Swarm.js serves one purpose: it synchronizes model
                        replicas in real time: client to server, server to
                        server or client to client.
                        It is like Dropbox for objects inside your web app.-->
New opportunities bring new challenges; having all that smartphones and tablets
on WiFi/3G, we now need handover (aka continuity), real time sync and offline work.

Those requirements stressed classic architectures leading to fix-on-a-fix stacks
that still can't fully exploit new HTML5 features such as WebSocket or WebStorage.

<!--Several kinds of server-side and client-side storage, APIs, event pushers, you name it.-->

CRDT is the only approach that allows to fully embrace the reality of distributed
data: we deal with the same data no matter where it resides (see infocentricity).

Our dream is to develop distributed applications the way we did good old local
MVC apps, by fully delegating the data caching/sync magic to a dedicated layer.

Swarm is a replicated model lib (M of MVC) that keeps your data correctly cached
and synchronized in real time using any storage and transport available.

                    </p>

                </td>

                <td>

                </td>

            </tr>

            <tr class='example mice'>
                <td>
                    <iframe src='../mice/index.html#1'></iframe>
                </td>
                <td class='legend'>
                    <!--h2>Mice</h2>
                    <ul>
                        <li>move your mouse over an IFRAME to see
                        pointers sync</li>
                        <li>last-writer-wins consistency model</li>
                        <li>synchronized by WebSocket to different
                        servers; servers sync to each other</li>
                        <li>shows all the currently connected users</li>
                    </ul-->
                    <img src='scheme1.png' width='300'>
                    <p> In this example, mouse pointer positions are
                        synchronized in real-time using WebSocket connections
                        to a node.js server. <br/>
                        Thus, you'll see mouse pointers
                        of all the people currently playing with this demo.
                        Just move your mouse over an iframe.
                        </p>
                </td>
                <td>
                    <iframe src='../mice/index.html#2'></iframe>
                </td>
            </tr>

            <tr class='example editor'>
                <td>
                    <iframe src='../editor/index.html#1'></iframe>
                </td>
                <td class='legend'>
                    <!--h2>Editor</h2>
                    <ul>
                        <li>edit the text to see it sync; disconnect
                        an IFRAME to create offline/consurrency cases</li>
                        <li>Causalt Trees consistency model (CT is
                        <b>not</b> OT!)</li>
                        <li>synchronized by WebStorage</li>
                        <li>shows only your activity</li>
                    </ul-->
                    <img src='scheme2.jpg' width='300'>
                    <p> In this example, a text is synced in real time using
                        a simplistic CT implementation (Causal Trees, a CRDT
                        flavor). Technically, frames sync using WebStorage,
                        i.e. purely offline, no server connections used. The
                        text survives <a href='index.html'>page refresh</a>. <br/>
                        Just start typing!</p>
                </td>
                <td>
                    <iframe src='../editor/index.html#2'></iframe>
                </td>
            </tr>

            <tr class='example conference'>
                <td><iframe src='../conf/index.html#1'></iframe></td>
                <td class='legend'>
                    <!--h2>Controls</h2>
                    <ul>
                        <li>play with the controls to see data sync</li>
                        <li>oplog-based consistency model</li>
                        <li>synchronized by postMessage channel via
                        the parent (this) IFRAME.</li>
                        <li>shows only your activity</li>
                    </ul-->
                    <img src='scheme3.png' width='300'>
                    <p>
                        Here, a user may plan his schedule at CAP'14 conference.
                        Frames sync locally to a parent frame using postMessage.
                        The parent frame syncs to the server to save data
                        and calculate attendance stats.<br/>
                        Just select talks you want to attend :)</p>
                </td>

                <td><iframe src='../conf/index.html#2'></iframe></td>
            </tr>

        </table>

        <div class=story>
            <p>The problem of data synchronization is indeed purely
            technical with no direct relation to your business
            logic. Still, in a complex web app sync becomes an
            issue. Just try to implement real-time sync,
            supporting mobile devices and intermittent connectivity,
            caching and soon you will find yourself on the toughest
            pages in a CS textbook.
            </p>
            <p>Swarm employs op-based eventual consistency approach.
            Based on a partially ordered operation log it
            implements variety of consistency algorithms.
            Swarm supports various sync channels: WebSocket for
            browser-to-server sync, WebStorage for tab-to-tab,
            postMessage for IFRAME-to-IFRAME sync, WebRTC for
            browser-to-browser, Stream for process-to-process and
            finally solid-fuel rockets for surface-to-air
            synchronization.
            </p>
            <p>Swarm works well offline and under intermittent
            connectivity; it may cache data and resync it later,
            incuding the case of browser restart (if the data
            stays in WebStorage).
            </p>
            <p>Our vision to write distributed apps like good old MVC apps.
            Just write a proper MVC app then scale it to a
            distributed environment by synchronizing your models
            with Swarm.
            </p>
        </div>

        <!-- How is it different
            Meteor
            Google Drive Realtime API
            Kafka per-object granularity (not a general bus) client-side
            -->

        <script src="../../lib/swarm3.js"></script>
        <script src="../../lib/swarm3-murmur.js"></script>
        <script src="../../lib/swarm3-client.js"></script>
        <script src="../../test/0_routines.js"></script>
        <script src="../conf/model/conf_model.js"></script>
        <script src="./datalink.js"></script>

        <a href="https://github.com/gritzko/swarm"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    </body>
</html>
