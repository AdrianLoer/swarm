<html>
    <head>
        <title></title>
        <link rel="stylesheet" href="demo3.css">
    </head>
    <body>

        <table>

            <tr>

                <td colspan='3' class='preamble'>
                    <p class='head'>
                        <img src='swarm.png' id='title'></img>
                    </p>
                    <p class='subtitle'>reactive data sync lib:
                        replicated model for your web app</p>

                    <p class='summary'>
New opportunities bring new challenges; now, having all that laptops,
smartphones and tablets on WiFi/3G, we need handover (aka <a
    href='https://www.apple.com/ios/ios8/continuity/'>continuity</a>),
real time sync and <a href='http://alistapart.com/article/offline-first'>offline work</a>.
Those requirements stressed classic request-response HTTP
architectures leading to
<a href='http://memcached.org/'>fix</a>-on-a-<a
    href='http://code.tutsplus.com/tutorials/getting-real-time-with-pusher--net-22106'>fix</a>
stacks that are far from
perfection.

Our dream is to develop distributed applications like good old local
MVC apps, by fully delegating the data caching/synchronization magic
to a dedicated layer.  We want to deal with the same data uniformly,
<a href='http://en.wikipedia.org/wiki/Named_data_networking'>no matter
where it resides</a>.

<!--that still can't fully exploit new HTML5 features such as
WebSocket or
WebStorage.-->

<!--Several kinds of server-side and client-side storage, APIs, event pushers, you name it.-->

We believe, that CRDT is the only approach that allows to fully embrace
the reality of distributed data.
Swarm is a CRDT-based replicated model library (M of MVC) that keeps
your data correctly cached and synchronized in real time using any
storage and transport available.

                        <!--It is like Dropbox for objects inside your web app.-->
                    </p>

                </td>

                <td>

                </td>

            </tr>

            <tr class='example mice'>
                <td>
                    <iframe src='../mice/index.html#1'></iframe>
                </td>
                <td class='legend'>
                    <!--h2>Mice</h2>
                    <ul>
                        <li>move your mouse over an IFRAME to see
                        pointers sync</li>
                        <li>last-writer-wins consistency model</li>
                        <li>synchronized by WebSocket to different
                        servers; servers sync to each other</li>
                        <li>shows all the currently connected users</li>
                    </ul-->
                    <img src='scheme1.png' width='300'>
                    <p> In this example, mouse pointer positions are
                        synchronized in real-time using WebSocket connections
                        to a node.js server. View rendering is done by
                        Facebook's
                        <a href='http://facebook.github.io/react/'>React.js</a>.<br/>
                        Thus, you'll see mouse pointers
                        of all the people currently playing with this demo.
                        Just move your mouse over an iframe.
                        </p>
                </td>
                <td>
                    <iframe src='../mice/index.html#2'></iframe>
                </td>
            </tr>

            <tr class='example editor'>
                <td>
                    <iframe src='../editor/index.html#1'></iframe>
                </td>
                <td class='legend'>
                    <!--h2>Editor</h2>
                    <ul>
                        <li>shows only your activity</li>
                    </ul-->
                    <img src='scheme2.png' width='300'>
                    <p>
In this example, a text is synced in real time using a simplistic CT
implementation
(<a href='http://www.pds.ewi.tudelft.nl/~victor/polo.pdf'>Causal
 Trees</a>, a CRDT flavor). Technically, frames sync using <a
 href='http://www.w3.org/TR/webstorage/#the-storage-event'>WebStorage</a>,
i.e. purely offline, no server connections used. The text survives <a
 href='index.html'>page refresh</a>. <br/> Just start typing!  </p>
                </td>
                <td>
                    <iframe src='../editor/index.html#2'></iframe>
                </td>
            </tr>

            <tr class='example conference'>
                <td><iframe src='../conf/index.html#1'></iframe></td>
                <td class='legend'>
                    <!--h2>Controls</h2>
                    <ul>
                        <li>play with the controls to see data sync</li>
                        <li>oplog-based consistency model</li>
                        <li>synchronized by postMessage channel via
                        the parent (this) IFRAME.</li>
                        <li>shows only your activity</li>
                    </ul-->
                    <img src='scheme3.png' width='300'>
                    <p>
                        Here, a user may plan his schedule at the CAP'14 conference.
                        Frames sync locally to a parent frame using postMessage.
                        The parent frame syncs to the server to save data
                        and calculate attendance stats.<br/>
                        Just select talks you want to attend :)</p>
                </td>

                <td><iframe src='../conf/index.html#2'></iframe></td>
            </tr>

        </table>

        <div class=story>

            <!-- PROBLEM -->
            <p>The problem of data synchronization is indeed purely
            technical with no direct relation to the business
            logic.
            Still, data sync becomes an issue in a complex web app.
            It is still a major challenge to implement real-time sync,
            intermittent connectivity support and caching.
            Very soon, you will find yourself on the toughest
            pages of a CS textbook (see AP of
            <a href='http://blog.foundationdb.com/minimal-explanation-of-the-cap-theorem'>CAP</a>).
            </p>

            <!-- DREAM -->
            <p>
            Our vision is to write distributed apps the way we did good old
            local MVC apps.
            The MVC loop naturally assumes there is no difference in processing
            local and remote events.
            Once replica synchronization is delegated to middleware,
            developers may concentrate on logic and presentation.
            <!--Once an app limits itself to local replica,-->

            Our other goal is smooth scaling path.
            <!--Once logic and presentation are clearly defined and nicely contained
            in thier respective blocks, scaling is achieved by plugging the
            right data source.-->
            A developer should be able to start an app using Chrome as an IDE and
            local storage as a backend, then switch to SaaS and later on to
            own backend cluster.
            That "deployment" stage slows down development way too often!

            Again, our way is: define the logic over a local replica, sync the
            replica in the background. That is like Dropbox for your objects.
            </p>

            <!-- METHOD -->
            <p>
            Once every client hosts a replica of (some) data,
            we deal with a radically ditributed AP system (by CAP)
            which needs to be reconciled all the time.
            And yes, "reconciled" means "eventual consistency".

            Mathematically, the most bulletproof approach to
            the problem was CRDT (Convergent Replicated Data Types).
            The CRDT theory is a dramatic improvement on Operational
            Transformation in handling concurrent changes in
            near-real-time systems.
            CRDT is fundamentally asynchronous, survives intermittent
            connectivity and perfectly matches reactive architectures.
            </p>

            <p>
            On the engineering side, our mission was to design a minimal
            CRDT basis to implement a lightweight Backbone-like
            framework on top of it.

            Swarm employs pure op-based CRDT flavor, where
            an object is essentially a stream of mutation events (ops).
            Based on those <a href='http://en.wikipedia.org/wiki/Partially_ordered_set'>partially ordered</a> <a href='http://en.wikipedia.org/wiki/Lamport_timestamps'>Lamport-timestamped</a> operation logs, Swarm implements CRDT data types.

          <!--(Differently from classic replication techniques,
          there is no op log linearization. Differently from OT,
          operations are immutable.)

          The foundation is a polog
          reactive at its core
          Triple-mode exchange: state, diff, op.-->

            Swarm operations are represented as key-value pairs where
            the key is a "specifier", a compound id consisting of class, object id,
            Lamport timestamp and operation name. The value is arbitrary JSON.
            All the operation routing, ordering, storage and application
            is based on specifiers.
            </p>

            <code>/Mouse#Mickey!8V7N809+Walt~ssn.set  {x: 266, y: 201}</code>

            <!-- DETAILS -->
            <p>
            Speaking of Swarm API, the best option at this moment is to
            learn by example and by reading
            <a href='/lib/swarm3.js'>the code</a>.
            Swarm implements M of MVC, so key classes are:

            <ul class='classes'>
            <li><tt>Model</tt> is a Backbone-like synced JavaScript object
                (extends Syncable).
            <li><tt>Set</tt> is the Swarm primary collection type (extends Syncable).
            Differently from Backbone, that is not an array, because arrays
            behave poorly under concurrent edits. Still, a Set can be sorted.
            <li><tt>Syncable</tt> is an abstract base class that implements most
            of op(log)
            related logic. A Syncable is an abstract object that is "synced".
            Syncables have a number of hidden fields, _version and _id being the
            most important. The _oplog field contains some of the applied operations;
            which and how many depends on implementation (e.g. see
            <a href='http://kafka.apache.org/documentation.html#compaction'>log
            compaction</a> discussion by Kreps).
            <li><tt>Host</tt> is (practically) a user session, and (formally) a partial
            replica of a dataset.
            <li><tt>Storage</tt> is (formally) a replica that does not implement
            the logic. Practically, that is a storage :)
            Normally, Storage implementations use some dual state+log scheme to
            persist replicas.
            <li><tt>Pipe</tt> is a connection to a remote Host backed by a standard
            node.js-compatible <a href='http://nodejs.org/api/stream.html'>Stream</a>.
            Pipes and Streams are mostly used internally.
            An average developer is supposed to simply use URIs.
            </ul>

            Here is a simple replica initialization example:
            </p>

<iframe src="http://pastebin.com/embed_iframe.php?i=iYH2Q6nD" style="border:none;width:100%"></iframe>

            <!--Swarm supports various sync channels: WebSocket for
            browser-to-server sync, WebStorage for tab-to-tab,
            postMessage for IFRAME-to-IFRAME sync, WebRTC for
            browser-to-browser, POSIX pipes for process-to-process and
            finally solid-fuel rockets for surface-to-air
            synchronization.-->


            <!-- CALL TO ACTION -->
            <p class='cta'>Swarm works well offline and under intermittent
            connectivity; it may cache data and resync it later,
            incuding the case of browser restart. <br/>

            Please, feel free to:
            <ul>
                <li><a href='https://github.com/gritzko/swarm/'>play</a> with it,
                <li>provide <a href='https://github.com/gritzko/swarm/issues/new'>feedback</a>,
                <li><a href='https://github.com/gritzko/swarm/issues/new'>report bugs, add feature
                    requests,</a>
                <li><a href='https://github.com/gritzko/swarm'>contribute</a>.
            </ul>
            Finally, this short intro may be too incomplete, so feel
            free to ask questions.
            </p>

            <h3>Links</h3>
            <ul class='links'>
                <li>GitHub project <a href='https://github.com/gritzko/swarm'>github.com/gritzko/swarm</a>
                <li>Swarm blog <a href='http://swarmjs.github.io/'>swarmjs.github.io</a>
                <li>Swarm and CRDTs, <a href='http://www.pds.ewi.tudelft.nl/~victor/polo.pdf'>short article</a>
                <li>Pure op-based CRDT <a href='http://gsd.di.uminho.pt/members/cbm/ps/crdtOpsMiddleware.pdf'>article</a>
            </ul>
        </div>

        <br/>

        <!-- How is it different
            Meteor
            Google Drive Realtime API
            Kafka per-object granularity (not a general bus) client-side
            -->

        <script src="../../lib/swarm3.js"></script>
        <script src="../../lib/swarm3-murmur.js"></script>
        <script src="../../lib/swarm3-client.js"></script>
        <script src="../../test/0_routines.js"></script>
        <script src="../conf/model/conf_model.js"></script>
        <script src="./datalink.js"></script>

        <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_shortname = 'swarmjs';

                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


        <a href="https://github.com/gritzko/swarm"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    </body>
</html>
